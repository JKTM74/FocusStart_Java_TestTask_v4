# FocusStart_Java_TestTask_v4

<h2>Задача:</h2>
Написать программу сортировки слиянием нескольких файлов.

<h2>Описание:</h2>
<p>Программа написана в среде разработки IntelliJ IDEA, выполнена в виде утилиты, для запуска из комндной строки, где в аргументы 
пользователь передает:<p>
<p>1. режим сортировки (-a или -d), необязательный, по умолчанию сортируем по возрастанию;</p>
<p>2. тип данных (-s или -i), обязательный;</p>
<p>3. имя выходного файла, обязательное;</p>
<p>4. остальные параметры – имена входных файлов, не менее одного.</p> 
<p><h2>Решение:</h2>
<p>Алгоритм решения основан на алгоритме сортировки слиянием, измененном под конкретную задачу. Так как все данные в входных файлах 
предварительно отсортированы, они уже готовы для слияния. Со всех файлов мы берём элемент в соответствии с положением каретки 
(изначально - первая строка каждого файла) и сохраняем их в массив. Далее находим в этом массиве элемент, который удовлетворяет условиям 
сортировки (минимальный либо максимальный), сравниваем с предыдущим записанным в файл элементом и записываем в файл, если он не нарушит
порядок в результирующем в файле. Если же элемент нарушает порядок в результирующем файле - он записан не будет, а каретка в файле с
этим элементом сместится на единицу (один шаг каретки = одной строке в файле).</p>

<h2>Описание классов и их методов:</h2>
<h3>MergeSort.java</h3>
<p>В конструкторе сохраняем параметры в глобальных переменных и в зависимости от метода сортировки уcтанавливаем значение lastInt.</p>
<p>В данном классе содержится десять методов:</p>  
<p><b>sortArray</b> - создает экземпляры класса ReadFile для каждого имени файла из параметров и запускаем сортировку в соответствии с 
типом данных.</p>
<p><b>deleteOutputFile</b> - удаляет результирующий файл, если он существует.</p> 
<p><b>getDataInt</b> - получает из каждого файла число в соответствии с текущим положением каретки и передает массив с 
числами в метод записи в файл.</p> 
<p><b>getDataStr</b> - получает из каждого файла строку в соответствии с текущим положением каретки и передает массив с 
строками в метод записи в файл.</p> 
<p><b>writeOutputInt</b> - сравниваем число с предыдущим записанным в файл числом, записывает в файл если 
число удовлетворяет условиям.</p> 
<p><b>writeOutputStr</b> - сравнивает строку с предыдущей записанной в файл строкой, записывает в файл если 
строка удовлетворяет условиям.</p> 
<p><b>getIntElement</b> - получает нужное (max || min) число и увеличивает значение каретки файла, откуда получено число на 1.</p> 
<p><b>getStrElement</b> - получает нужную (max || min) строку и увеличивает значение каретки файла, откуда получена строка на 1.</p> 
<p><b>checkLine</b> - возвращает true если проверяемая строка меньше чем предыдущая строка (по таблице ASCII), иначе false.</p> 
<p><b>isNumeric</b> - проверяет, можно ли преобразовать строку в число. Возвращает true, если можно и false, если нельзя.</p> 
<p></p>
<h3>ReadFile.java</h3>
<p>В конструкторе сохраняем в глобальную переменную имя файла.</p>
<p>В данном классе содержится три метода:</p> 
<p><b>getElement</b> - возвращает строку из файла в соответствии с положением каретки.</p> 
<p><b>isEof</b> - возвращает true, если файл закончился и false, если нет.</p> 
<p><b>incrementCounter</b> - увеличивает положение каретки на 1.</p>
<h2>Заключение:</h2>
<p>Я выбрал именно такой способ слияния файлов, так как считаю что он является оптимальным с точки зрения затраченного на выполнение
времени. В случае слияния файлов последоательно, будет выполнено большее колличество итераций,что займет больше времени, чем при
слиянии всех файлов одновременно. Минус моего алгоритма в том, что можно потерять больше данных, если в входных файлах данные будут 
оформленны не верно.</p>
